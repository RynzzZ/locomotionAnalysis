% OBSTACLE AVOIDANCE ANALYSIS

% to do: limit to middle trials // separate successful trials // ??? base analysis on obsPosition from rotary encoder RATHER than wheel position???


% user settings
dataDir = 'C:\Users\Rick\Google Drive\columbia\obstacleData\sessions\';
mouse = 'run3';

obsPrePost = [.1 .5]; % meters // plot this much before and after the obstacle turns on
obsOnPos = 0.4236; % meters // distance for which obstacle is lit up // this was hack-ily determined emperically in matlab... knowing this value ahead of time makes the coding much simpler though...
posRes = .001; % resolution of x axis, in meters
ylims = [.1 .6]; % m/s



% initializations
sessionInfo = readtable([dataDir 'sessionInfo.xlsx']);

sessionInds = strcmp(sessionInfo.mouse, mouse) &...
              strcmp(sessionInfo.experiment, 'obsTest') &...
              sessionInfo.include;
sessions = sessionInfo.session(sessionInds);

posInterp = -obsPrePost(1) : posRes : (obsOnPos+obsPrePost(2)); % velocities will be interpolated across this grid of positional values

cmap = copper(length(sessions));
close all; figure;
subplot(1,2,2); bar(nan(1,length(sessions))); hold on % ghost bar plot to get our axis labels



% iterate over sessions
for i = 1:length(sessions)

    % load session data
    load([dataDir sessions{i} '\run.mat'], 'ObsLight', 'touch');
    load([dataDir sessions{i} '\runAnalyzed.mat'],...
            'wheelPositions', 'wheelTimes', 'rewardTimes', 'targetFs');
    obsOnTimes = ObsLight.times(logical(ObsLight.level)); % important: assumes first event is HIGH... not sure how this will behave otherwise...
    
    % get touch times
    % !!! i should really debounce these signals so the duration of touch is interpretable... currently duration is not interpretable
    touchTimes = touch.times(logical([0; diff(touch.values>3)==1]));

    % compute velocity
    vel = getVelocity(wheelPositions, .5, targetFs);

    
    
    % iterate over all trials, computing velocity vs. position
    trialVels = cell(length(obsOnTimes));
    sessionVels = nan(length(obsOnTimes), length(posInterp));
    obsAvoided = nan(1,length(obsOnTimes));

    for j = 1:length(obsOnTimes)

        % locate trial
        onInd  = find(wheelTimes > obsOnTimes(j), 1, 'first');    
        onPos = wheelPositions(onInd);

        % get trial positions and velocities
        trialInds = (wheelPositions > onPos-obsPrePost(1)) & (wheelPositions < onPos+obsOnPos+obsPrePost(2));
        trialPos = wheelPositions(trialInds);
        trialPos = trialPos - trialPos(1); % baseline normalize
        trialVel = vel(trialInds);

        % remove duplicate positional values
        [trialPos, uniqueInds] = unique(trialPos, 'stable');
        trialVel = trialVel(uniqueInds);

        % interpolate velocities across positional grid
        trialVelInterp = interp1(trialPos, trialVel, posInterp, 'linear', 'extrap');

        % store results
        sessionVels(j,:) = trialVelInterp;
        
        % determine whether obstacle was avoided
        onTime =  wheelTimes(find(wheelPositions>onPos,1,'first'));
        offTime = wheelTimes(find(wheelPositions<(onPos+obsOnPos),1,'last'));
        obsAvoided(j) = ~any(touchTimes>onTime & touchTimes<offTime);
    end
    
    % plot session mean velocity
    subplot(1,2,1)
    plot(posInterp, mean(sessionVels,1), 'color', cmap(i,:), 'linewidth', 2); hold on
    
    % plot session success rate
    subplot(1,2,2)
    bar(i, mean(obsAvoided), 'facecolor', cmap(i,:)); hold on
end



% pimp figure out
pimpFig; set(gcf, 'menubar', 'none', 'position', [.2 .4 .6 .4])

subplot(1,2,1)
set(gca, 'xlim', [-obsPrePost(1) (obsOnPos+obsPrePost(2))], 'ylim', ylims)
xlabel('position (m)')
ylabel('speed (m/s)')
line([0 0], ylims, 'color', [0 0 0])
line([obsOnPos obsOnPos], ylims, 'color', [0 0 0])

subplot(1,2,2)
xlabel('session #')
ylabel('% avoidance')




