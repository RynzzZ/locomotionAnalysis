function [positions, times] = rotaryDecoder(aTimes, aStates, bTimes, bStates)

    % converts quadrature input from rotary encoder into real world positional units (m)
    % uses a lookup table method, where every encoder input is represented
    % as a transition of a 2 bit state to another 2 bit state (the two bits
    % being the states of the two encoder channels). this 4 bit code is
    % used to index into a lookup table that tells whether the encoder has
    % moved forward, back, or stayed stationary
    %
    % input        aTimes, bTimes:   times of state shifts in the A and B channels from the rotary encoder
    % 	           aStates, bStates: levels of A and B rotary encoder at times of state shifts
    % output       positions:        position of wheel in meters
    %              times:            times of all position values
    

    tic
    
    % wheel, encoder settings
    encoderSteps = 2880; % 720cpr * 4
    wheelRad = 95.25; % mm
    mmPerTic = (2*wheelRad*pi) / encoderSteps;
    
    % convert all inputs to row vectors
    aTimes = aTimes(:)';
    bTimes = bTimes(:)';
    aStates = logical(aStates(:))';
    bStates = logical(bStates(:))';

    lookUp = [0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0];
    deltas = nan(size(times));

    prevState = [~aStates(1) ~bStates(1)]; % the initial state of encoders A and B

    for i = 1:round(length(identities))/100

        currentState = prevState;
        currentState(identities(i)+1) = ~prevState(identities(i)+1);
        lookupInd = [prevState currentState];
        deltas(i) = lookUp(bin2dec(num2str(lookupInd))+1);
        prevState = currentState;

    end

    % convert to real-world units (m)
    positions = cumsum(deltas) * (mmPerTic / 1000);
    
    decodingTime = toc/60; % minutes
    fprintf('rotary decoding time: %f minutes\n', decodingTime)
    
end











