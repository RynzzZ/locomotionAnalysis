file = 'C:\Users\LindseyBuckingham\Google Drive\columbia\analysis\run.mat';
load(file);

%%
aTimes = whEncodA.times';
bTimes = whEncodB.times';
aStates = logical(whEncodA.level)';
bStates = logical(whEncodB.level)';

% sort encoder events by time of occurence
times = [aTimes bTimes];
[times, sortInds] = sort(times);

% create identities vector, where each element represents whether encoder A (0) or B (1) has changed state
% this is the most economical representation of the encoder data, because the states can be inferred at all times if you known the starting state of both channels and the times at which those channels change
identities = [zeros(1, length(aTimes)) ones(1, length(bTimes))];
identities = identities(sortInds);

%%

tic


lookUp = [0,-1,1,0,1,0,0,-1,-1,0,0,1,0,1,-1,0];
deltas = nan(size(times));

prevState = [~aStates(1) ~bStates(1)]; % the initial state of encoders A and B

for i = 1:round(length(identities)/100)
%     tic
    
    currentState = prevState;
    currentState(identities(i+1)) = ~identities(i+1);
    transitionCode = [prevState currentState];
    deltas(i) = lookUp(bin2dec(num2str(transitionCode))+1);
    prevState = currentState;
    
    
    
    
    
%     loopTime = toc;
%     loopTime = (loopTime*length(times)*2) / 60;
%     fprintf('total analysis time: %f\n', loopTime)
end

close all; figure; plot(cumsum(deltas(1:find(isnan(deltas),1,'first')))); pimpFig


toc / 60
